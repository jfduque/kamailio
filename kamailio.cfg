#!define WITH_MYSQL #!define WITH_AUTH
#!define WITH_ASTERISK

//WITH_FWD_REG_ASTERISK is turned off because Kamailio will maintain Registrations
##define WITH_FWD_REG_ASTERISK

#!define WITH_MULTIDOMAIN
#!define WITH_HOMER_SECURITY_CHECKS
##define WITH_ANTIFLOOD
#!define WITH_NAT
##define WITH_DISPATCHER
#!define WITH_RELAYING
#!define WITH_DEBUG
#!define WITH_WEBSOCKETS
#!define WITH_TLS
##define WITH_TCP
#!define WITH_DETECT_ASTERISK
//WITH_SANITYCHECKS is disabled because of reported issue (unverified); verify before renenabling 
##define WITH_SANITYCHECKS

                        //Debugging defines
//WITH_CHATTY will enable the printing of L_INFO messages for INFO, and OPTIONS
#!define WITH_CHATTY
//TEST_WEBSOCKETS is used to test flow between Kamalio and http/https clients
##define TEST_WEBSOCKETS


/*                                                FUNCTIONS
##############################################################################################################################

nat_uac_test("n"): try to determine if request originated behind a NAT
  1 - The “Contact” header field is searched for occurrence of RFC1918 or RFC6598 addresses.
  2 - the "received" test is used: address in the “Via” header is compared against source IP address of signaling
  4 - The Top Most “Via” is searched for occurrence of RFC1918 or RFC6598 addresses
  8 - The SDP is searched for occurrence of RFC1918 or RFC6598 addresses
  16 - Test if the source port is different from the port in the “Via” header
  32 - Test if the source IP address of signaling is a RFC1918 or RFC6598 address
  64 - Test if the source connection of signaling is a WebSocket
  128 - Test if the “Contact” header URI port differs from the source port of the request

NOTE: The following NAT helper functions do not appear to function correctly in some environments, some or
      all of them may need to be commented out in order to function in a nated envireonmnet

- fix_nated_contact() creates URI consisting of Source  IP, Port,and Protocol, URI is appended to Contact in the '200 OK'
- set_contact_alias(); add alias to contact 
- add_contact_alias(); same as set_contact_alias() (Depricated) 
- handle_ruri_alias(); if ruri has an alias then set du equal to the alias;

##############################################################################################################################
*/

#
# Kamailio (OpenSER) SIP Server v5.0 - default configuration script
#     - web: https://www.kamailio.org
#     - git: https://github.com/kamailio/kamailio
#
# Direct your questions about this file to: <sr-users@lists.kamailio.org>
#
# Refer to the Core CookBook at https://www.kamailio.org/wiki/
# for an explanation of possible statements, functions and parameters.
#
# Note: the comments can be:
#     - lines starting with #, but not the pre-processor directives,
#       which start with #!, like #!define, #!ifdef, #!endif, #!else, #!trydef,
#       #!subst, #!substdef, ...
#     - lines starting with //
#     - blocks enclosed in between /* */
#
# Several features can be enabled using '#!define WITH_FEATURE' directives:
#
# *** To run in debug mode:
#     - define WITH_DEBUG
#
# *** To enable mysql:
#     - define WITH_MYSQL
#
# *** To enable authentication execute:
#     - enable mysql
#     - define WITH_AUTH
#     - add users using 'kamctl'
#
# *** To enable IP authentication execute:
#     - enable mysql
#     - enable authentication
#     - define WITH_IPAUTH
#     - add IP addresses with group id '1' to 'address' table
#
# *** To enable persistent user location execute:
#     - enable mysql
#     - define WITH_USRLOCDB
#
# *** To enable presence server execute:
#     - enable mysql
#     - define WITH_PRESENCE
#
# *** To enable nat traversal execute:
#     - define WITH_NAT
#     - install RTPProxy: http://www.rtpproxy.org
#     - start RTPProxy:
#        rtpproxy -l _your_public_ip_ -s udp:localhost:7722
#     - option for NAT SIP OPTIONS keepalives: WITH_NATSIPPING
#
# *** To enable PSTN gateway routing execute:
#     - define WITH_PSTN
#     - set the value of pstn.gw_ip
#     - check route[PSTN] for regexp routing condition
#
# *** To enable database aliases lookup execute:
#     - enable mysql
#     - define WITH_ALIASDB
#
# *** To enable speed dial lookup execute:
#     - enable mysql
#     - define WITH_SPEEDDIAL
#
# *** To enable multi-domain support execute:
#     - enable mysql
#     - define WITH_MULTIDOMAIN
#
# *** To enable TLS support execute:
#     - adjust CFGDIR/tls.cfg as needed
#     - define WITH_TLS
#
# *** To enable XMLRPC support execute:
#     - define WITH_XMLRPC
#     - adjust route[XMLRPC] for access policy
#
# *** To enable anti-flood detection execute:
#     - adjust pike and htable=>ipban settings as needed (default is
#       block if more than 16 requests in 2 seconds and ban for 300 seconds)
#     - define WITH_ANTIFLOOD
#
# *** To block 3XX redirect replies execute:
#     - define WITH_BLOCK3XX
#
# *** To block 401 and 407 authentication replies execute:
#     - define WITH_BLOCK401407
#
# *** To enable VoiceMail routing execute:
#     - define WITH_VOICEMAIL
#     - set the value of voicemail.srv_ip
#     - adjust the value of voicemail.srv_port
#
# *** To enhance accounting execute:
#     - enable mysql
#     - define WITH_ACCDB
#     - add following columns to database
# *** To enable testing a web socket connection 
#     This will test a TLS/wss web socket connection 
#     - define TEST_WEBSOKET
#
#!ifdef ACCDB_COMMENT
  ALTER TABLE acc ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE acc ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE acc ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_domain VARCHAR(128) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN src_ip varchar(64) NOT NULL default '';
  ALTER TABLE missed_calls ADD COLUMN dst_ouser VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_user VARCHAR(64) NOT NULL DEFAULT '';
  ALTER TABLE missed_calls ADD COLUMN dst_domain VARCHAR(128) NOT NULL DEFAULT '';
#!endif

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########
# *** Value defines - IDs used later in config
#!ifdef WITH_MYSQL
# - database URL - used to connect to database server by modules such
#       as: auth_db, acc, usrloc, a.s.o.
#!ifndef DBURL
#!define DBURL "mysql://kamailio:KAMAILIO-DB-PW@localhost/kamailio"
#!ifdef WITH_ASTERISK
#!define DBASTURL "mysql://asterisk:ASTERISK-DB-PW@localhost/asterisk"
#!endif
#!endif
#!endif

#!ifdef WITH_MULTIDOMAIN
# - the value for 'use_domain' parameters
#!define MULTIDOMAIN 1
#!else
#!define MULTIDOMAIN 0
#!endif

#               --- flags ---
#   FLT_ - per transaction (message) flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5
#   FLB_ - per branch flags
#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

// Kamailio's Private IP Address and Port information
#!substdef "!MY_IP_ADDR!KAMAILIO-PRIVATE-IP!g"
#!substdef "!MY_DOMAIN!KAMAILIO-PRIVATE-IP!g"
#!substdef "!MY_WS_PORT!80!g"
#!substdef "!MY_WSS_PORT!KAMAILIO-TLS-PORT!g"
#!substdef "!MY_WS_ADDR!tcp:MY_IP_ADDR:MY_WS_PORT!g"
#!substdef "!MY_WSS_ADDR!tls:MY_IP_ADDR:MY_WSS_PORT!g"


####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR, -n(2-5)=different levels of critical, -6=OFF
/* Note, if set to 3 (DBG), make sure to clear logs often or have lots of storage available. Large logs can stop the system */
#!ifdef WITH_DEBUG
debug=2
log_stderror=no
#!else
debug=-1
log_stderror=yes
#!endif
#$var(loglevel)=2;

#log_prefix="{M=$rm C=$ct R=$ru D=$du ID=$ci}"
#log_prefix_mode=1

/* if debug >= memdbg, then memory debugging is active */
memdbg=5
/* if debug >= memlog then, memory statistics is active (at shutdown) */
memlog=5

/* see local0 in /etc/rsyslog.conf; currently set to kamailio.log */
log_facility=LOG_LOCAL0
//if local0 not set then add the following line to /etc/rsyslog.conf
//local0.*                    /var/log/kamailio.log
//the restart rsyslog => systectl restart rsyslog

/* number of SIP routing processes */
fork=yes 
children=8

/* uncomment the next line to disable TCP (default on) */
#disable_tcp=yes
tcp_max_connections=4096

/* uncomment the next line to disable the auto discovery of local aliases
 * based on reverse DNS on IPs (default on) */
auto_aliases=no

/* add local domain aliases */
//other domains being served
//alias=FQDN:KAMAILIO-PORT
alias=FQDN

socket_workers=4
listen=tcp:KAMAILIO-PRIVATE-IP:KAMAILIO-PORT advertise KAMAILIO-PUBLIC-IP:KAMAILIO-PORT
/*
with additional listening port -
   => no video on agent with inbound calls and calls drop on (Z5,Z20, Z70?; toggle does not work)
   => no video on agent with outboud calls and calls drop on (ntouch)
without the additional listening port -
   => calls drop, depending on device? (Asterisk 15.x) 
*/
#listen=udp:KAMAILIO-PRIVATE-IP:KAMAILIO-DUAL-PORT advertise KAMAILIO-PUBLIC-IP:KAMAILIO-DUAL-PORT
listen=udp:KAMAILIO-PRIVATE-IP:KAMAILIO-PORT advertise KAMAILIO-PUBLIC-IP:KAMAILIO-PORT
listen=tls:KAMAILIO-PRIVATE-IP:KAMAILIO-TLS-PORT advertise KAMAILIO-PUBLIC-IP:KAMAILIO-TLS-PORT
#listen=udp:0.0.0.0:KAMAILIO-PORT 

/* port to listen to (default KAMAILIO-PORT for udp, tcp, scrtp, or 5061 for tls)*/
#port=KAMAILIO-PORT

enable_tls=no
#!ifdef WITH_TLS
enable_tls=yes	
#!endif

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

####### Custom Parameters #########

/* These parameters can be modified runtime via RPC interface
 * - see the documentation of 'cfg_rpc' module.
 *
 * Format: group.id = value 'desc' description
 * Access: $sel(cfg_get.group.id) or @cfg_get.group.id */

#!ifdef WITH_PSTN
/* PSTN GW Routing
 *
 * - pstn.gw_ip: valid IP or hostname as string value, example:
 * pstn.gw_ip = "10.0.0.101" desc "My PSTN GW Address"
 *
 * - by default is empty to avoid misrouting */
pstn.gw_ip = "" desc "PSTN GW Address"
pstn.gw_port = "" desc "PSTN GW Port"
#!endif

#!ifdef WITH_VOICEMAIL
/* VoiceMail Routing on offline, busy or no answer
 *
 * - by default Voicemail server IP is empty to avoid misrouting */
voicemail.srv_ip = "" desc "VoiceMail IP Address"
voicemail.srv_port = "KAMAILIO-PORT" desc "VoiceMail Port"
#!endif

 
#!ifdef WITH_ASTERISK
asterisk.bindip = "ASTERISK-PRIVATE-IP" desc "Asterisk IP Address"
//asterisk.publicip = "xxx.xxx.xxx.xxx" desc "Asterisk Public IP Address"
asterisk.bindport = "KAMAILIO-PORT" desc "Asterisk Port"
kamailio.bindip = "KAMAILIO-PRIVATE-IP" desc "Kamailio IP Address"
kamailio.bindport = "KAMAILIO-PORT" desc "Kamailio Port"
#!endif


####### Modules Section ########

/* set paths to location of modules */
mpath="/usr/local/lib64/kamailio/modules/"

/* multihomed - at this point I do not believe the proxy server will be multihomed */
mhomed=0

/* set server signature to no so that potential attackers will have less information about the proxy */
server_signature=no

/* Note: Kamalio will need to be recompiled and have myslq enable in order for the mysql.so to be available */
#!ifdef WITH_MYSQL
loadmodule "db_mysql.so"
loadmodule "sqlops.so"
#!endif

loadmodule "stun.so"
loadmodule "outbound.so"
loadmodule "jsonrpcs.so"
loadmodule "path.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "counters.so"
loadmodule "siptrace.so"
loadmodule "permissions.so"
loadmodule "dialog.so"
#loadmodule "signaling.so"
#loadmodule "tcpops.so"
#!ifdef WITH_DISPATCHER
loadmodule "dispatcher.so"
#!endif

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!ifdef WITH_IPAUTH
loadmodule "permissions.so"
#!endif
#!endif

#!ifdef WITH_ALIASDB
loadmodule "alias_db.so"
#!endif

#!ifdef WITH_SPEEDDIAL
loadmodule "speeddial.so"
#!endif

#!ifdef WITH_MULTIDOMAIN
loadmodule "domain.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

#!ifdef WITH_NAT
loadmodule "nathelper.so"
#loadmodule "rtpproxy.so"
loadmodule "rtpengine.so"
#!endif

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_ANTIFLOOD
loadmodule "htable.so"
loadmodule "pike.so"
#!endif

#!ifdef WITH_XMLRPC
loadmodule "xmlrpc.so"
#!endif

#!ifdef WITH_DEBUG
loadmodule "debugger.so"
#!endif

#!ifdef WITH_ASTERISK
loadmodule "uac.so"
#!endif

loadmodule "websocket.so"
loadmodule "xhttp.so"

/*
loadmodule "db_text.so"
modparam("db_text", "db_mode", 1)
*/

loadmodule "sdpops.so"

modparam("dialog", "dlg_flag", 4)

# ----------------- setting module-specific parameters ---------------

# ----- Turn on tracing -----
modparam("siptrace", "trace_on", 1)
modparam("siptrace", "trace_to_database", 1)
modparam("siptrace", "db_url", "mysql://kamailio:KAMAILIO-DB-PW@localhost/kamailio")
modparam("siptrace", "traced_user_avp", "$avp(user)")

#permissions
# All trusted domains will go into the trusted table.  This is very important when HOMER is enabled
modparam("permissions", "db_url", "mysql://kamailio:KAMAILIO-DB-PW@localhost/kamailio")
modparam("permissions", "trusted_table", "trusted")
modparam("permissions", "source_col", "src_ip")
modparam("permissions", "proto_col", "proto")

modparam("permissions", "address_table", "address")
modparam("permissions", "grp_col", "grp")
modparam("permissions", "ip_addr_col", "ip_addr")
modparam("permissions", "port_col", "port")

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- tm params (Allows statefull processing)-----
# auto-discard branches from previous serial forking leg
modparam("tm", "failure_reply_mode", 3)
# default retransmission timeout: 30sec
modparam("tm", "fr_timer", 450000)
# default invite retransmission timeout after 1xx: 120sec
modparam("tm", "fr_inv_timer", 120000)
# socket timeout => without this, rtpproxy has send errors ???
#modparam("tm", "unix_tx_timeout", 5000)

# ----- rr params (record routing) -----
# when using two disconnected networks or X-platform routing from UDP->TCP, double_rr is needed
# Also important to be on if your system is dobule nated
######################################################################
modparam("rr", "enable_double_rr", 1)
######################################################################

# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 1)

# do not append from tag to the RR 
#!ifdef WITH_ASTERISK
   modparam("rr", "append_fromtag", 1)
#!else
   modparam("rr", "append_fromtag", 0)
#!endif

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
/* uncomment the next line to disable parallel forking via location */
# modparam("registrar", "append_branches", 0)
/* uncomment the next line not to allow more than 10 contacts per AOR */
# modparam("registrar", "max_contacts", 10)
/* max value for expires of registrations */
modparam("registrar", "max_expires", 3600)
/* set it to 1 to enable GRUU (Globally Routable User Agents)*/
modparam("registrar", "gruu_enabled", 0)
//Path support
modparam("registrar", "use_path", 1) 
modparam("registrar", "path_mode", 1) 
modparam("registrar", "path_use_received", 2) 

# ----- acc params -----
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
/* by default ww do not adjust the direct of the sequential requests.
 * if you enable this parameter, be sure the enable "append_fromtag"
 * in "rr" module */
modparam("acc", "detect_direction", 0)
/* account triggers (flags) */
modparam("acc", "log_flag", FLT_ACC)
modparam("acc", "log_missed_flag", FLT_ACCMISSED)
modparam("acc", "log_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
modparam("acc", "failed_transaction_flag", FLT_ACCFAILED)
/* enhanced DB accounting */
#!ifdef WITH_ACCDB
modparam("acc", "db_flag", FLT_ACC)
modparam("acc", "db_missed_flag", FLT_ACCMISSED)
modparam("acc", "db_url", DBURL)
modparam("acc", "db_extra",
	"src_user=$fU;src_domain=$fd;src_ip=$si;"
	"dst_ouser=$tU;dst_user=$rU;dst_domain=$rd")
#!endif

# ----- usrloc params -----
/* enable DB persistency for location entries */
#!ifdef WITH_USRLOCDB
modparam("usrloc", "db_url", DBURL)
modparam("usrloc", "db_mode", 2)
modparam("usrloc", "use_domain", MULTIDOMAIN)
#!endif

# ----- auth_db params -----
#!ifdef WITH_AUTH
modparam("auth_db", "calculate_ha1", 1)
#modparam("auth_db", "load_credentials", "")
#!ifdef WITH_ASTERISK
modparam("auth_db", "user_column", "name")
modparam("auth_db", "password_column", "sippasswd")
modparam("auth_db", "db_url", DBASTURL)
modparam("auth_db", "version_table", 0)
modparam("auth_db", "use_domain", 0)
#modparam("auth_db", "version_table", 0)
#!else
modparam("auth_db", "db_url", DBURL)
modparam("auth_db", "password_column", "password")
modparam("auth_db", "use_domain", MULTIDOMAIN)
#!endif
# ----- permissions params -----
#!ifdef WITH_IPAUTH
modparam("permissions", "db_url", DBURL)
modparam("permissions", "db_mode", 1)
#!endif

#!endif

# ----- alias_db params -----
#!ifdef WITH_ALIASDB
modparam("alias_db", "db_url", DBURL)
modparam("alias_db", "use_domain", MULTIDOMAIN)
#!endif

# ----- speeddial params -----
#!ifdef WITH_SPEEDDIAL
modparam("speeddial", "db_url", DBURL)
modparam("speeddial", "use_domain", MULTIDOMAIN)
#!endif

# ----- domain params -----
#!ifdef WITH_MULTIDOMAIN
modparam("domain", "db_url", DBURL)
/* register callback to match myself condition with domains list */
modparam("domain", "register_myself", 1)
#!endif

#!ifdef WITH_PRESENCE
# ----- presence params -----
modparam("presence", "db_url", DBURL)

# ----- presence_xml params -----
modparam("presence_xml", "db_url", DBURL)
modparam("presence_xml", "force_active", 1)
#!endif

#!ifdef WITH_NAT
# ----- rtpproxy params -----
#examples for variation of proxy locations and port
#modparam("rtpproxy", "rtpproxy_sock", "udp:127.0.0.1:7721")
#modparam("rtpproxy", "rtpproxy_sock", "udp:localhost:12221")
#modparam("rtpproxy", "rtpproxy_sock", "unix:/var/run/rtpproxy/rtpproxy.sock")
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:12221")

#Turn Proxy off
#modparam("rtpproxy", "rtpproxy_sock", "")

# ----- nathelper params -----
#modparam("nathelper", "natping_interval", 0)
#modparam("nathelper", "ping_nated_only", 1)
#modparam("nathelper", "sipping_bflag", FLB_NATSIPPING)
#modparam("nathelper", "sipping_from", "sip:pinger@kamailio.org")

# params needed for NAT traversal in other modules
modparam("nathelper|registrar", "received_avp", "$avp(RECEIVED)")
modparam("usrloc", "nat_bflag", FLB_NATB)
#!endif

#!ifdef WITH_TLS
# ----- tls params -----
#modparam("tls", "config", "/usr/local/etc/kamailio/tls.cfg")
modparam("tls", "cipher_list", "AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA")
#modparam("tls", "cipher_list", "NULL")
modparam("tls", "private_key", "/etc/asterisk/keys/asterisk.pem")
modparam("tls", "certificate", "/etc/asterisk/keys/asterisk.pem")
#!endif

#!ifdef WITH_ANTIFLOOD
# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 16)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 5 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=300;")
#!endif

#!ifdef WITH_XMLRPC
# ----- xmlrpc params -----
modparam("xmlrpc", "route", "XMLRPC");
modparam("xmlrpc", "url_match", "^/RPC")
#!endif

#!ifdef WITH_DEBUG
# ----- debugger params -----
#cfgtrace 0 => do not log cofiguration log messages; 1=> log configuration log messages
#Warning => turning this on can produce huge kamaili.log files, it must be tuned
modparam("debugger", "cfgtrace", 0)
modparam("debugger", "log_level_name", "exec")
#!endif

#!ifdef WITH_DISPATCHER
# Dispatching for Load Balancing
modparam("dispatcher", "db_url", "mysql://kamailioro:KAMAILIO-DB-PW@localhost/kamailio")
modparam("dispatcher", "table_name", "dispatcher")
modparam("dispatcher", "flags", 2)
modparam("dispatcher", "dst_avp", "$avp(AVP_DST)")
modparam("dispatcher", "grp_avp", "$avp(AVP_GRP)")
modparam("dispatcher", "cnt_avp", "$avp(AVP_CNT)")
modparam("dispatcher", "sock_avp", "$avp(AVP_SOCK)")
/*
modparam("dispatcher", "ds_ping_method", "OPTIONS")
modparam("dispatcher", "ds_ping_reply_codes", "class=2;class=4")
modparam("dispatcher", "ds_probing_mode", 1)
modparam("dispatcher", "ds_ping_interval", 30)
*/

#force overwriting of destination address (outbound proxy) when that is already set. If set to 0, will return error when destination
#address is already set.
modparam("dispatcher", "force_dst", 1)
#use_default set to 1=> use last entry as fail-over; defaut is 0=> use all for dispatching
modparam("dispatcher", "use_default", 0)
#!endif

#!ifdef WITH_MYSQL
modparam("sqlops","sqlcon","ca=>mysql://asterisk:ASTERISK-DB-PW@localhost/asterisk")
#!endif

# if enabled and "1" => first route URI is used as destination URI
#modparm("path", "use_received", 1)

pv_buffer_size=16384;

//Needed for webRTC
tcp_accept_no_cl=yes;

/*
use the same socket assigned in the listen, only available starting with 5.1.x
If you do not use reuse port, you will need to make sure your firwall is open
for the ports that Kamailio/kernal randomly create
*/
tcp_reuse_port=yes; 

//set tcp buffer sizes
tcp_conn_wq_max=64000;
tcp_rd_buf_size=64000;


####### SIP Routing Logic ########

/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */

modparam("pv", "varset", "inittransport=s:init")
route {

       xlog("L_INFO","FLOW - route\n");
       #work around for preventing a known attack 
       if($(hdr(To)[1]) != $null) {
         xlog("L_INFO", "Header attack - The second To Header is not null => dropping message");
         drop;
       }

       xlog("L_INFO","=>Setting Transport");

#!ifdef WITH_CHATTY
  $avp(chatty) = "yes";
#!else
  $avp(chatty) = "no";
#!endif

        if($var(inittransport)=="init") {
          if(search("KAMAILIO-PUBLIC-IP") || search("FQDN")) {
            //if(search("svrs")) {
             //  record_route_advertised_address("KAMAILIO-PRIVATE-IP:15061");
	    //}
            $avp(transtype) = "udp";
          }
          else {
            $avp(transtype) = "tcp";
          }
        }
        $var(init_transport)="complete";

        xlog("L_INFO","=>transtype:$avp(transtype)");
        xlog("L_INFO","=>init_transport:$var(init_transport)");
	#sdp_remove_codecs_by_name("VP8");
	#sdp_keep_codecs_by_name("H264","VP8");
        if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
          xlog("L_INFO","   FLOW : SIP Incoming Request: [[$mb");
        };

#!ifdef WITH_HOMER_SECURITY_CHECKS
        route(HOMER_SECURITY_CHECKS);
#!endif

        if(method=="INFO-IGNORE") {
	  xlog("L_INFO","Request is INFO => ignoring");
	  sl_send_reply("200","OK");
	  exit;
        }
        else {
	  xlog("L_INFO","Dbg=>Calling route(REQINT)\n");
	  # per request initial checks
	  route(REQINIT);
        };

#!ifdef WITH_WEBSOCKETS
	if (nat_uac_test(64)) {
	   xdbg("Dbg=>call from Web Socket received\n");
	   # Do NAT traversal stuff for requests from a WebSocket
	   # connection - even if it is not behind a NAT!
	   # This won't be needed in the future if Kamailio and the
	   # WebSocket client support Outbound and Path.
	   //STEVE force_rport();
	   if (is_method("REGISTER")) {
	     fix_nated_register();
	   } 
           else {
             xlog("L_INFO","route du before add_contact_alias: $du\n");
             xlog("L_INFO","route ru before add_contact_alias: $ru\n");
/*
	     if (!add_contact_alias()) {
	       xlog("L_ERR", "Error aliasing contact <$ct>\n");
               xlog("L_INFO","=>SIP Reply '400 - Bad Request'\n");
               xlog("L_INFO","");
	       sl_send_reply("400", "Bad Request");
	       exit;
	     }
*/
             xlog("L_INFO","route du after add_contact_alias: $du\n");
             xlog("L_INFO","route ru after add_contact_alias: $ru\n");
	   }
	}
#!endif

	# NAT detection
	xdbg("Dbg=>calling route(NATDETECT)\n");
	route(NATDETECT);

	# CANCEL processing
	if (is_method("CANCEL")) {
           rtpengine_delete();
	   if (t_check_trans()) {
	      xdbg("Dbg=>calling route(RELAY)\n");
	      route(RELAY);
	      exit;
	   }
	}

	# handle retransmissions
	if (!is_method("ACK")) {
	   xdbg("=>Checking for retransmissions\n");
	   if(t_precheck_trans()) {
	      xdbg("Dbg=>Handeling retransmissions\n");
	      t_check_trans();
	      exit;
	   }
	   t_check_trans();
        }

	# handle requests within SIP dialogs
	xdbg("Dbg=>calling route(WITHINDLG)\n");
	route(WITHINDLG);

	### only initial requests (no To tag)
	t_check_trans();

	# authentication
	xdbg("Dbg=>calling route(AUTH)\n");
	route(AUTH);

	# record routing for dialog forming requests (in case they are routed)
	# - remove preloaded route headers
	remove_hf("Route");
	if (is_method("INVITE|SUBSCRIBE")) {
           xlog("L_INFO","  => HELLO (INVITE) in route");
/*
           xlog("L_INFO","  => ci:$ci\n");
           xlog("L_INFO","  => du:$du\n");
           xlog("L_INFO","  => ru:$ru\n");
           xlog("L_INFO","  => su:$su\n");
           xlog("L_INFO","  => sut:$sut\n");
           xlog("L_INFO","  => branch route:$br\n");
           xlog("L_INFO","  => contact header:$ct\n");
           xlog("L_INFO","  => destination port(dp):$dp\n");
           xlog("L_INFO","  => destination transport protocol(dP):$dP\n");
           xlog("L_INFO","  => port of original R-URI(op):$op\n");
           xlog("L_INFO","  => protocol of original R-URI(oP):$oP\n");
           xlog("L_INFO","  => port of R-URI(rp):$rp\n");
           xlog("L_INFO","  => protocol of R-URI(rP):$rP\n");
           xlog("L_INFO","  => source ip(si):$si\n");
           xlog("L_INFO","  => source port(sp):$sp\n");
           xlog("L_INFO","  => from URI domain(fd):$fd\n");
           xlog("L_INFO","  => from URI prefered(pu):$pu\n");
           xlog("L_INFO","  => from URI(fd):$fd\n");
           xlog("L_INFO","  => to URI(tu):$tu\n");
           xlog("L_INFO","  => received IP address(Ri):$Ri\n");
           xlog("L_INFO","  => tt:$tt\n");
           xlog("L_INFO","  => from tag domain(ft):$ft\n");
           xlog("L_INFO","  => fu: $fu\n");
           xlog("L_INFO","  => rU: $rU\n");
           xlog("L_INFO","  => fU: $fU\n");
           xlog("L_INFO","  => oU: $oU\n");
           xlog("L_INFO","  => tU: $tU\n");
           xlog("L_INFO","  => user agent(ua): $ua\n");
           xlog("L_INFO","  => force socket(fs):$fs\n");
           $var(sutport) = $(sut{uri.port});
           xlog("L_INFO","  => sut port:$var(sutport)\n");
           xlog("L_INFO","  => IP from INVITE:$dlg_var(callerip)\n");
           xlog("L_INFO","  => PORT from INVITE:$dlg_var(callerport)\n");
           xlog("L_INFO","  => CONTACT from INVITE:$dlg_var(callercontact)\n");
           xlog("L_INFO","  => Number Called:$dlg_var(numbercalled)\n");
*/

           $dlg_var(callerip) = $si;
           $dlg_var(callerport) = $sp;
           $dlg_var(callercontact) = $(ct{s.substr,1,0});
           $dlg_var(callercontact) = $(dlg_var(callercontact){s.select,-2,:});
           $dlg_var(numbercalled) = $(ru{s.select,0,@});

           dlg_manage();
           xlog("L_INFO","  => caller ip:$dlg_var(callerip)");
           xlog("L_INFO","  => caller port:$dlg_var(callerport)");
           xlog("L_INFO","  => caller contact:$dlg_var(callercontact)");
           xlog("L_INFO","  => caller number called:$dlg_var(numbercalled)");
           
	   record_route();
           xlog("L_INFO","  => Setting record routes: $fd");
	}

	# account only INVITEs
	if (is_method("INVITE")) {
	   setflag(FLT_ACC); # do accounting
	}

/* REMOVED HANG UP ISSUE => had no effect
	if (is_method("OPTIONS|INFO")) {
           xlog("L_INFO","=>method is OPTIONS , or INFO and IP-Address is approved => Sending 200 OK\n");
	   #sl_send_reply("200","OK");
	   record_route();
	}
*/


	# dispatch requests to foreign domains
	xdbg("Dbg=>calling route(SIPOUT)\n");
	route(SIPOUT);

	### requests for my local domains

	# handle presence related requests
	xdbg("Dbg=>calling route(PRESENCE)\n");
	route(PRESENCE);

	# handle registrations
	xdbg("Dbg=>calling route(REGISTRAR) $rU\n");
	route(REGISTRAR);

        #xlog("L_INFO","Dbg=>Source URI:$si\n");
/*
        if(($si=="ASTERISK-BACKUP-PRIVATE-IP" || $si=="ASTERISK-PRIVATE-IP") && is_method("OPTIONS") && allow_source_address(1)) {
           xlog("L_INFO","=>method is OPTIONS , or INFO and IP-Address is approved => Sending 200 OK\n");
           #Do not call options_reply() unless you really know what you are doing, see documnentation
           #options_reply();
           //xlog("L_INFO","=>SIP Reply '200 - OK'\n\n");
	   sl_send_reply("200","OK");
	   return;
        }
*/

	if ($rU==$null) {
	   # request with no Username in RURI
           xlog("L_INFO","=>Address Incomplete $rU\n");
	   #sl_send_reply("484","Address Incomplete");
	   exit;
        }

#!ifndef WITH_DISPATCHER
	# dispatch destinations to PSTN
	xdbg("Dbg=>calling route(PSTN)\n");
	route(PSTN);
#!else
	xlog("L_INFO", "=>In Dispatcher");
        route(DISPATCHER);
#!endif

	# user location service
	xlog("L_DBG", "=>calling route(LOCATION)\n");
	route(LOCATION);

}

# Wrapper for relaying requests
route[RELAY] {
        xlog("L_INFO","FLOW - route[RELAY]\n");

#!ifdef WITH_NAT
        if (check_route_param("nat=yes")) {
           setbflag(FLB_NATB);
        }
        if(isflagset(FLT_NATS) || isbflagset(FLB_NATB)) {
           xlog("L_INFO", "Relay (use RTPPROXY if available)\n");
           route(RTPPROXY);   
        }
#!endif

	# enable additional event routes for forwarded requests
	# - serial forking, RTP relaying handling, a.s.o.
	if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
       	   if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
	}
	if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
	   if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
	}
	if (is_method("INVITE")) {

           //Keep track of who made the call
           $var(temp) = $(ct{s.select,-1,:});
           $dlg_var(contactport) = $(var(temp){s.select,0,>});
           $dlg_var(invitingagent) = $ua;
           dlg_manage();
           
           send_reply("183", "Ringing");
           xlog("L_INFO","=>SIP Reply '183 - Ringing'\n");
	   if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
	}
        
        xlog("L_INFO","  => ci:$ci\n");
        xlog("L_INFO","  => du:$du\n");
        xlog("L_INFO","  => ru:$ru\n");
        xlog("L_INFO","  => su:$su\n");
        xlog("L_INFO","  => sut:$sut\n");
        xlog("L_INFO","  => branch route:$br\n");
        xlog("L_INFO","  => contact header:$ct\n");
        xlog("L_INFO","  => destination port(dp):$dp\n");
        xlog("L_INFO","  => destination transport protocol(dP):$dP\n");
        xlog("L_INFO","  => port of original R-URI(op):$op\n");
        xlog("L_INFO","  => protocol of original R-URI(oP):$oP\n");
        xlog("L_INFO","  => port of R-URI(rp):$rp\n");
        xlog("L_INFO","  => protocol of R-URI(rP):$rP\n");
        xlog("L_INFO","  => source ip(si):$si\n");
        xlog("L_INFO","  => source port(sp):$sp\n");
        xlog("L_INFO","  => from URI domain(fd):$fd\n");
        xlog("L_INFO","  => from URI prefered(pu):$pu\n");
        xlog("L_INFO","  => from URI(fd):$fd\n");
        xlog("L_INFO","  => to URI(tu):$tu\n");
        xlog("L_INFO","  => received IP address(Ri):$Ri\n");
        xlog("L_INFO","  => tt:$tt\n");
        xlog("L_INFO","  => from tag domain(ft):$ft\n");
        xlog("L_INFO","  => fu: $fu\n");
        xlog("L_INFO","  => rU: $rU\n");
        xlog("L_INFO","  => fU: $fU\n");
        xlog("L_INFO","  => oU: $oU\n");
        xlog("L_INFO","  => tU: $tU\n");
        xlog("L_INFO","  => user agent(ua): $ua\n");
        xlog("L_INFO","  => user agent from invite(invitingagent): $dlg_var(invitingagent) \n");
        xlog("L_INFO","  => contact port from invite(contactport): $dlg_var(contactport) \n");
        xlog("L_INFO","  => force socket(fs):$fs\n");
        $var(sutport) = $(sut{uri.port});
        xlog("L_INFO","  => sut port:$var(sutport)\n");
        xlog("L_INFO","  => IP from INVITE:$dlg_var(callerip)\n");
        xlog("L_INFO","  => PORT from INVITE:$dlg_var(callerport)\n");
        xlog("L_INFO","  => CONTACT from INVITE:$dlg_var(callercontact)\n");
        xlog("L_INFO","  => Number Called:$dlg_var(numbercalled)\n");

########################################################################################
//INVITE REQUEST
if(method=="INVITE") {
   xlog("L_INFO","  => INVITE Logic\n");
}
########################################################################################
      
########################################################################################
//INFO REQUEST
#/* IOS: Z? Purple? was writting to the incorrect ru  
if(method=="INFO") {
   xlog("L_INFO","  => INFO Logic\n");
   if ($dlg_var(invitingagent) =~ "^Purple") {
      if ($du =~ "^sip:KAMAILIO-PRIVATE-IP" || $du =~ "^sip:ASTERISK-PRIVATE-IP"  || $du =~ "^sip:ASTERISK-BACKUP-PRIVATE-IP") {
         xlog("L_INFO","  => INFO to Proxy or Asterisk, leave ru as is\n");
      }
      else {
         xlog("L_INFO","  => INFO from Proxy or Asterisk, reset ru and du\n");
         $avp(ruip) = $(ru{s.select,0,;});
         $avp(ruip) = $(avp(ruip){s.substr,4,0});
         xlog("L_INFO","  =>    numbercalled: $dlg_var(numbercalled)\n");
         xlog("L_INFO","  =>    callerip: $dlg_var(callerip)\n");
         xlog("L_INFO","  =>    contactport: $dlg_var(contactport)\n");
         xlog("L_INFO","  =>    ruip: $avp(ruip)\n");
         $ru = "sip:" + $tU+ "@" + $dlg_var(callerip) + ":" + $dlg_var(contactport);
         $du = "sip:" + $fd + ":" + "KAMAILIO-PORT";
         xlog("L_INFO","  => INFO Adjusted ru(Contact): $ru\n");
         xlog("L_INFO","  => INFO du: $du\n");
      }
   }
}
#*/
########################################################################################

########################################################################################
//BYE REQUEST
if(method=="BYE") {
  xlog("L_INFO","  => BYE Logic\n");
/*
//P3
  $du="sip:"+$dlg_var(callerip)+":KAMAILIO-PORT;transport=tcp;";
  if(is_present_hf("Route"))
      remove_hf("Route");
  $ru = $dlg_var(numbercalled) + "@" + $dlg_var(callerip) + ":" + $dlg_var(contactport) +";alias=" + $dlg_var(callerip) +"~"+$dlg_var(callerport)+"~2";
  xlog("L_INFO","  => du before relay: $du\n");
  xlog("L_INFO","  => ru before relay: $ru\n");
//P3
*/

/*
//Convo
  #get ru from  re-invite, if it exists
  if ($dlg_var(callerip)="ASTERISK-PRIVATE-IP" || $dlg_var(callerip)="ASTERISK-BACKUP-PRIVATE-IP") {
     xlog("L_INFO","  => do not reset ru, because invite from Asterisk\n");
     xlog("L_INFO","  => reset ru, because invite from Asterisk\n");
     #get ru from re-invite, if it exists
     xlog("L_INFO","  => searching for phone number in:$ru\n");
     $avp(numbercalled) = $(ru{s.select,0,@});
     xlog("L_INFO","  => numbercalled:$avp(numbercalled)\n");
     $ru = $avp(numbercalled) + "@KAMAILIO-PRIVATE-IP:KAMAILIO-PORT;transport=tcp;" + "alias=" + $dlg_var(callerip) +"~"+$dlg_var(callerport)+"~2";
     xlog("L_INFO","  => du before relay: $du\n");
     xlog("L_INFO","  => ru before relay: $ru\n");
  }
  else {
     xlog("L_INFO","  => do not reset ru, because invite from Asterisk\n");
  }
//Convo
*/

/*
//Z5 IOS
  $avp(sipiptosendto) = $(ru{s.select,0,;});
  xlog("L_INFO","  => sipiptosendto: $avp(sipiptosendto)\n");
  $avp(iptosendto) = $(avp(sipiptosendto){s.select,1,:});
  xlog("L_INFO","  => iptosendto: $avp(iptosendto)\n");
  
  #if(is_present_hf("Route")) {
  #    remove_hf("Route");
  #}
  $du=$avp(sipiptosendto) + ":KAMAILIO-PORT" + ";transport=tcp";
  $ru="sip:"+ "+18135404671" + "@" + $avp(iptosendto) + ":" + $dlg_var(contactport) + ";transport=tcp";
  xlog("L_INFO","  => NEW du before relay: $du\n");
  xlog("L_INFO","  => NEW ru before relay: $ru\n");
//Z5 IOS
*/

//Apply BYE Request logic based on provider, Note: some providers will work with default config#

  //Sorenson
  if ($dlg_var(invitingagent) =~ "^Sorenson") {
     xlog("L_INFO","  =>  Processing  $dlg_var(invitingagent) Type Devices\n");
     xlog("L_INFO","  =>  contact port: $dlg_var(contactport)\n");
     if ($du =~ "^sip:KAMAILIO-PRIVATE-IP" || $du =~ "^sip:ASTERISK-PRIVATE-IP"  || $du =~ "^sip:ASTERISK-BACKUP-PRIVATE-IP") {
        xlog("L_INFO","  =>  du to Proxy or Asterisk, Do Not Adjust ru\n");
     }
     else {
        xlog("L_INFO","  =>  du to Provider, Adjust ru => \n");
        $du = "sip:" + $dlg_var(callercontact) + ":" + $dlg_var(callerport)  + ";transport=tcp";
     }
  }

  //Purple 
  if ($dlg_var(invitingagent) =~ "^Purple") {
     xlog("L_INFO","  =>  Processing  $dlg_var(invitingagent) Type Devices\n");
     xlog("L_INFO","  =>  contact port: $dlg_var(contactport)\n");
     if ($du =~ "^sip:KAMAILIO-PRIVATE-IP" || $du =~ "^sip:ASTERISK-PRIVATE-IP"  || $du =~ "^sip:ASTERISK-BACKUP-PRIVATE-IP") {
        xlog("L_INFO","  =>  du to Proxy or Asterisk, Do Not Adjust ru\n");
     }
     else {
        if ($du =~ "^sip:KAMAILIO-PUBLIC-IP" || $du == $null) {
           xlog("L_INFO","  =>  Sending via route 1\n");

           ##################################################
           xlog("L_INFO","  =>    Removing Record-Route\n");
           if(is_present_hf("Record_Route")) {
              remove_hf("Record_Route");
           }
           ##################################################

           ##################################################
           xlog("L_INFO","  =>    Resetting ru and du\n");
           $du = "sip:" + $fd + ":" + $dlg_var(callerport) + ";transport=tcp";
           $ru = $tu + ":" + $dlg_var(contactport);
           ##################################################

           ##################################################
           xlog("L_INFO","  =>    Resetting Route Header\n");
           remove_hf("Route");
           insert_hf("Route: <sip:$fd;lr;r2=on>\r\n");
           insert_hf("Route: <sip:$fd;transport=tcp;lr;r2=on>\r\n");
           ##################################################

           xlog("L_INFO","  =>  du: $du\n");
           xlog("L_INFO","  =>  ru after Adjustment: $ru\n");
        }
        else {
           xlog("L_INFO","  =>  Sending via route 2\n");
////
           $avp(temp) = $(du{s.select,0,;});
           $avp(iptosendto) = $(avp(temp){s.strip,4});
           //$avp(iptosendto) = $fd;
////
           xlog("L_INFO","  =>    Resetting ru\n");
           xlog("L_INFO","  =>  send BYE to: $avp(iptosendto):$dlg_var(contactport) via tansport: $dP \n");
           $ru="sip:" + $tU +"@" + $avp(iptosendto)  + ":" + $dlg_var(contactport);
           //$du = "sip:" + $avp(iptosendto) + ":" + $dp + ";" + $dP;
           xlog("L_INFO","  =>  du: $du\n");
           xlog("L_INFO","  =>  ru after Adjustment: $ru\n");
        }
     }
  }

  //Linphone Logic
  if ($dlg_var(invitingagent) =~ "^Linphone") {
     xlog("L_INFO","  =>  Processing  $dlg_var(invitingagent) Type Devices\n");
     xlog("L_INFO","  =>  contact port: $dlg_var(contactport)\n");
     if ($du =~ "^sip:KAMAILIO-PRIVATE-IP" || $du =~ "^sip:ASTERISK-PRIVATE-IP"  || $du =~ "^sip:ASTERISK-BACKUP-PRIVATE-IP") {
        xlog("L_INFO","  =>  du to Proxy or Asterisk, Do Not Adjust ru\n");
     }
     else {
        xlog("L_INFO","  =>  du to Provider, Adjust ru => \n");
        if ($du =~ "^sip:KAMAILIO-PUBLIC-IP" || $du == $null) {
           //NOTE: Purple is not responding to any request after the INVITE (INFO's was changed just to keep calls from disconnecting)
           if(is_present_hf("Route")) {
              remove_hf("Route");
           }
           xlog("L_INFO","  =>  Sending via route 1\n");

           ##################################################
           //send via tcp, response => "not here"
           $du = "sip:" + $dlg_var(callerip) + ":" + $dlg_var(callerport) + ";transport=tcp";
           //send with udp, response => no response
           //$du="sip:" + $fd + ":" + $dlg_var(callerport);
           ##################################################
           #$ru = $tu;
           xlog("L_INFO","  =>  building up ru\n");
           xlog("L_INFO","  =>    dlg_var(callerip): $dlg_var(callerip) \n");
           xlog("L_INFO","  =>    dlg_var(calleport): $dlg_var(callerport) \n");
           $ru = "sip:" + $tU + "@" + $dlg_var(callerip) + ":" + $dlg_var(callerport);

           xlog("L_INFO","  =>  du: $du\n");
           xlog("L_INFO","  =>  ru after Adjustment: $ru\n");
        }
        else {
           xlog("L_INFO","  =>  Sending via route 2\n");
        }
     }
  }

}
########################################################################################

//RELAY

        #t_relay_to_tcp()) => force to use tcp 
        #t_relay() => use transport from INVITE
        #######################################
        if($avp(transtype)=="tcp") {
          xlog("L_INFO","   FLOW : t_relay_to_tcp\n");
          #force_send_socket(KAMAILIO-PRIVATE-IP:KAMAILIO-PORT);
          $fs = "tcp:KAMAILIO-PRIVATE-IP:KAMAILIO-PORT";
          if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
            xlog("L_INFO","  =>SIP TCP Relaying: [$mb");
          }
          if (!t_relay_to_tcp()) {
	    sl_reply_error();
	  }
        }
        else {
          xlog("L_INFO","   FLOW : Sending t_relay\n");
          if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
            xlog("L_INFO","  =>SIP UDP Relaying: [$mb]");
	  }
	  if (!t_relay()) {
	    sl_reply_error();
	  }
        }
        //sip_trace();
	exit;
}

#!ifdef WITH_DISPATCHER
route[DISPATCHER] {
  xlog("L_INFO","FLOW - route[DISPATCHER]\n");
  # round-robin dispatching on gateways group '1', 4=>round-robin
  if(!ds_select_dst("1", "4")) {
     xdbg("Dbg=>No destination \n");
     send_reply("404", "No destination");
     exit;
  }
  xdbg("Dbg=>Going to $ru via $du \n");
  t_on_failure("RTF_DISPATCH");
  xlog("L_INFO","=>route(DISPATCHER) Complete \n");
  return;
}
#!endif

# Per SIP request initial checks
route[REQINIT] {
        xlog("L_INFO","FLOW - route[REQINIT]\n");
	xdbg("Dbg=> In route[REQINIT] Checking for valid - trusted users\n"); 
#!ifdef WITH_ANTIFLOOD
	# flood detection from same IP and traffic ban for a while
	# be sure you exclude checking trusted peers, such as pstn gateways
	# - local host excluded (e.g., loop to self)
	if(src_ip!=myself) {
	   if($sht(ipban=>$si)!=$null) {
	      # ip is already blocked
	      xdbg("request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
	      xlog("L_INFO","ALERT: request from blocked $rm from $fu (IP:$si:$sp)\n");
	      exit;
	   }
	   if (!pike_check_req()) {
	      xlog("L_ALERT","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
	      xlog("L_INFO","ALERT: pike blocking $rm from $fu (IP:$si:$sp)\n");
	      $sht(ipban=>$si) = 1;
	      exit;
	   }
	}
	if($ua =~ "friendly-scanner|sipcli") {
	   # silent drop for scanners - uncomment next line if want to reply
           xlog("L_INFO","=>friendly-scanner\n");
           xlog("L_INFO","=>SIP Reply '200 - OK'\n\n");
           xlog("L_INFO","");
	   sl_send_reply("200", "OK");
	   exit;
	}
#!endif

	if (!mf_process_maxfwd_header("10")) {
           xlog("L_INFO","=>SIP Reply '483 - Too Many Hops'\n");
           xlog("L_INFO","");
	   sl_send_reply("483","Too Many Hops");
	   exit;
	}

	if(is_method("OPTIONS") && uri==myself && $rU==$null) {
           xlog("L_INFO","=>SIP Reply '200 - Keepalive'\n");
           xlog("L_INFO","");
	   sl_send_reply("200","Keepalive");
	   exit;
	}

#!ifdef WITH_SANITYCHECKS
        # there has been reports of sanity_check causing missing ACK's (I have not been able to verify this, so use with caution)
	if(!sanity_check("1511", "7")) {
	   xlog("Malformed SIP message from $si:$sp\n");
	   exit;
	}
#!endif
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
        xlog("L_INFO","FLOW - route[WITHINDLG]\n");
        if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
	   xlog("L_INFO","=>In route(WITHINDLG) handeling Requests within SIP dialog\n");
        }
	if (!has_totag()) {
           if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
	      xlog("L_INFO","=>No totag in WITHINDLG so returning\n");
           }
           return;
        }
	xlog("L_INFO","=>totag in WITHINDLG Found, continuing\n");

	# sequential request withing a dialog should
	# take the path determined by record-routing
	if (loose_route()) {
           if(is_method("BYE")) {
              rtpengine_manage("ICE=force");
              //rtpengine_manage();
           }
           xlog("L_INFO", "=>In loose-route:uri\n");
/* REMOVE NOW
# attempt to fix missing ACK issue because of Asterisk sending Public IP in Contact-Header ?????hmmmmm
	   if(has_totag() && uri==myself && $ru=~";alias=") {
	      xlog("L_INFO", "Warning=>Attempting to fix missing ACK issue\n");
              xlog("L_INFO","WITHINDLG du before handle_ruri_alias: $du\n");
              xlog("L_INFO","WITHINDLG ru before handle_ruri_alias: $ru\n");
	      handle_ruri_alias();
              xlog("L_INFO","WITHINDLG du after handle_ruri_alias: $du\n");
              xlog("L_INFO","WITHINDLG ru after handle_ruri_alias: $ru\n");
	      if($du != $null) {
                 xlog("L_INFO","WITHINDLG Setting ru=du\n");
	         $ru = $du;
              }
	   }
REMOVE NOW */
#

	   xdbg("Dbg=>in loose_route section\n");
#!ifdef WITH_WEBSOCKETS
/*
	   if ($du == "") {
	     if (!handle_ruri_alias()) {
	       xlog("L_INFO", "=>Bad alias <$ru>\n");
               xlog("L_INFO","=>SIP Reply '400 - Bad Request'\n");
               xlog("L_INFO","");
	       sl_send_reply("400", "Bad Request");
	       exit;
	     }
	   }
*/
#!endif
	   route(DLGURI);
	   if (is_method("BYE")) {
	      setflag(FLT_ACC); # do accounting ...
	      setflag(FLT_ACCFAILED); # ... even if the transaction fails
	   } 
           else if ( is_method("ACK") ) {
	      # ACK is forwarded statelessly
	      route(NATMANAGE);
	   } 
           else if ( is_method("NOTIFY") ) {
	      # Add Record-Route for in-dialog NOTIFY as per RFC 6665.
	      record_route();
	   }
	   route(RELAY);
	   exit;
	}
        else {
	  if (is_method("SUBSCRIBE") && uri == myself) {
	     # in-dialog subscribe requests
	     route(PRESENCE);
	     exit;
	  }
	  if ( is_method("ACK") ) {
	    if ( t_check_trans() ) {
	      # no loose-route, but stateful ACK;
	      # must be an ACK after a 487
	      # or e.g. 404 from upstream server
	      route(RELAY);
	      exit;
	    }  
            else {
	      # ACK without matching transaction ... ignore and discard
              xlog("L_INFO","ERROR=>ACK without matching transaction");
	      exit;
	   }
       	  }
          xlog("L_INFO","=>SIP Reply '404 - Not here'\n");
          xlog("L_INFO","");
	  sl_send_reply("404","Not here");
        }
	exit;
}

# Handle SIP registrations
route[REGISTRAR] {
        xlog("L_INFO","FLOW - route[REGISTER]\n");
	if (is_method("REGISTER")) {
           xlog("L_INFO","=>REGISTERING In route[REGISTER]\n");
	   if(isflagset(FLT_NATS)) {
	      setbflag(FLB_NATB);
#!ifdef WITH_NATSIPPING
	      # do SIP NAT pinging
	      setbflag(FLB_NATSIPPING);
#!endif
	   }
	   #add_path_received();
	   xlog("L_INFO","=>Calling save(location)\n");
	   if (!save("location")) {
	      sl_reply_error();
	      xlog("L_INFO","=>save(location) failed=>exiting\n");
	   }
	    
#!ifdef WITH_FWD_REG_ASTERISK
           /*
           Before forwading Registrations make sure you really know what you are doing because
           one of the main features of kamailio is that it is maintaining the registration.
           */
	   //route(REGFWD);
           route(TOASTERISK);
	   xlog("L_INFO","=>route[REGISTER] Complete\n");
#!endif
	}
	//exit; //STEVE NEW 5/11/2018 
}

# User location service
route[LOCATION] {
        xlog("L_INFO","FLOW - route[LOCATION] => does nothing, if not WITH_SPEEDDIAL\n");
        xlog("L_DBG", "=>In route[LOCATION]\n");

#!ifdef WITH_SPEEDDIAL
	# search for short dialing - 2-digit extension
	if($rU=~"^[0-9][0-9]$") {
	   if(sd_lookup("speed_dial")) {
	      route(SIPOUT);
	   }
	}
#!endif

#!ifdef WITH_ALIASDB
	# search in DB-based aliases
	if(alias_db_lookup("dbaliases")) {
	   route(SIPOUT);
	}
#!endif

#!ifdef WITH_ASTERISK
	if(is_method("INVITE") && (!route(FROMASTERISK))) {
	   # if new call from out there - send to Asterisk
	   # - non-INVITE request are routed directly by Kamailio
	   # - traffic from Asterisk is routed also directy by Kamailio
           if($avp(transtype) == "tcp") {
	      #forward outbound call to endpoint
              #xlog("L_INFO","=>INVITE to outbound endpoint=>forwarding call");
              #forward is stateless
              #xlog("L_INFO","=>Stateless INVITE not from Asterisk, Calling route(TOASTERISK)");
	      #forward();
              xlog("L_INFO","=>Statefull INVITE not from Asterisk, Calling route(TOASTERISK)");
	      route(TOASTERISK);
           }
           else {
	      #forward inbound call to Asterisk 
              xlog("L_INFO","=>INVITE not from Asterisk, Calling route(TOASTERISK)");
	      route(TOASTERISK);
           }
	   exit;
	}
#!endif
	$avp(oexten) = $rU;
	if (!lookup("location")) {
	   $var(rc) = $rc;
	   route(TOVOICEMAIL);
	   t_newtran();
	   switch ($var(rc)) {
	     case -1:
	     case -3:
	        send_reply("404", "Not Found");
	        exit;
	     case -2:
	        send_reply("405", "Method Not Allowed");
	        exit;
	   }
	}

	# when routing via usrloc, log the missed calls also
	if (is_method("INVITE")) {
	   setflag(FLT_ACCMISSED);
	}

	route(RELAY);
        xlog("L_INFO","=>route[LOCATION] Complete\n");
	exit;
}

# Presence server processing
route[PRESENCE] {
        xlog("L_INFO","FLOW - route[PRESENCE]\n");
	if(!is_method("PUBLISH|SUBSCRIBE")) return;

	if(is_method("SUBSCRIBE") && $hdr(Event)=="message-summary") {
	   route(TOVOICEMAIL);
	   # returns here if no voicemail server is configured
	   sl_send_reply("404", "No voicemail service");
	   exit;
	}

#!ifdef WITH_PRESENCE
	if (!t_newtran()) {
	   sl_reply_error();
	   exit;
        }	

	if(is_method("PUBLISH")) {
	   handle_publish();
	   t_release();
	} 
        else if(is_method("SUBSCRIBE")) {
	   handle_subscribe();
	   t_release();
	}
	exit;
#!endif

	# if presence enabled, this part will not be executed
	if (is_method("PUBLISH") || $rU==$null) {
           xlog("L_INFO","=>SIP Reply '404 - Not here'\n");
	   sl_send_reply("404", "Not here");
	   exit;
	}
	return;
}

# IP authorization and user authentication
route[AUTH] {
        xlog("L_INFO","FLOW - route[AUTH]\n");
#!ifdef WITH_AUTH
	# if caller is not local subscriber, then check if it calls
	# a local destination, otherwise deny, not an open relay here
#if open relaying allowed then continue if we are dealing with an open relay
#!ifndef WITH_RELAYING
	if (from_uri!=myself && uri!=myself) {
           xlog("L_INFO","=>SIP Reply '403 - Not relaying'\n");
	   sl_send_reply("403","Not relaying"); 
           xdbg("Dbg=> fu:$fu;ru:$ru\n");
	   exit;
	}
#!endif
 
#!ifdef WITH_ASTERISK
	# do not auth traffic from Asterisk - trusted!
	if(route(FROMASTERISK)) {
           xlog("L_DBG","=>Asterisk User(No Auth required)\n"); 
	   return;
        }
#!endif
 
#!ifdef WITH_IPAUTH
	if((!is_method("REGISTER")) && allow_source_address()) {
	   # source IP allowed
	   return;
	}
#!endif
 
	if (is_method("REGISTER") || from_uri==myself) { 
           xdbg("Dbg=>Authenticating for a REGISTER request\n"); 
	   # authenticate requests
#!ifdef WITH_ASTERISK
	   xdbg("Dbg=>authenticate:$fd\n"); 
	   if (!auth_check("$fd", "sipusers", "1")) {
#!else
           xdbg("Dbg=>challenge subscriber:$fd\n"); 
	   if (!auth_check("$fd", "subscriber", "1")) {
#!endif
	      xdbg("Dbg=>auth_check returned:$retcode \n"); 
	      auth_challenge("$fd", "0");
	      xdbg("Dbg=>auth_challenge complete\n"); 
	      exit;
	   }
	   # user authenticated - remove auth header
	   xdbg("Dbg=>authenticated\n"); 
	   if(!is_method("REGISTER|PUBLISH")) {
              consume_credentials();
	   }
        }
#!endif
	return;
}

# Caller NAT detection
route[NATDETECT] {
xlog("L_INFO","FLOW - route[NATDETECT]\n");
#!ifdef WITH_NAT
        if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
          xdbg("Dbg=>In route[NATDETECT]\n"); 
        }
        #add received port to top most Via Header
	force_rport();

#/*
//NOTE: Purple is not responding to any request after the INVITE (INFO's was changed just to keep calls from disconnecting)
//Needed to deal with picture-fast-updates flooding the line => P3
if(method=="INFO" && ($si=="ASTERISK-PRIVATE-IP" || $si=="ASTERISK-BACKUP-PRIVATE-IP") && $Ri=="KAMAILIO-PRIVATE-IP") {
  sl_send_reply("200", "OK");
  #exit;
}
#*/
	if (nat_uac_test("19")) {
          xdbg("Dbg=>Behind NAT\n"); 
	  if (is_method("REGISTER")) {
	     fix_nated_register();
	  } 
          else {
	     if(is_first_hop()) {
                xlog("L_INFO","NATDETECT du before set_contact_alias: $du\n");
                xlog("L_INFO","NATDETECT ru before set_contact_alias: $ru\n");
/*
		if(!set_contact_alias()) {
                   xdbg("Dbg=>Error aliasing: $ct\n"); 
                   send_reply("400", "Bad Request");
                }
*/
                xlog("L_INFO","NATDETECT du after set_contact_alias: $du\n");
                xlog("L_INFO","NATDETECT ru after set_contact_alias: $ru\n");
                xdbg("Dbg=>Contact Alias: $ct\n"); 
	     }
             xlog("L_INFO","NATDETECT du before add_contact_alias: $du\n");
             xlog("L_INFO","NATDETECT ru before add_contact_alias: $ru\n");
             add_contact_alias();
             xlog("L_INFO","NATDETECT du after add_contact_alias: $du\n");
             xlog("L_INFO","NATDETECT ru after add_contact_alias: $ru\n");
	  }
	  setflag(FLT_NATS);
	}
        if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
           xlog("L_INFO","=>In route[NATDETECT] Complete\n"); 
        }
#!endif
	return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
xlog("L_INFO","FLOW - route[NATMANAGE]\n");
#!ifdef WITH_NAT
	if (is_request()) {
           if(has_totag()) {
	      if(check_route_param("nat=yes")) {
		setbflag(FLB_NATB);
	      }
	   }
	}
	if (!(isflagset(FLT_NATS) || isbflagset(FLB_NATB))) {
	  xdbg("Dbg=>exiting NATMANGE because of flagset\n");
          return;
        }

	if (is_request()) {
	   if (!has_totag()) {
	      if(t_is_branch_route()) {
                 xdbg("Dbg=>In route[NATDETECT] adding ;nat yes route\n"); 
	         add_rr_param(";nat=yes");
	      }
              else {
                 xdbg("Dbg=> not is branch route\n"); 
              }
	   }
           else {
              xdbg("Dbg=>no totag in NATMANAGE\n"); 
           }
	}
	if (is_reply()) {
	   if(isbflagset(FLB_NATB)) {
	      if(is_first_hop()) {
                 xlog("L_INFO","NATMANAGE du before handle_ruri_alias: $du\n");
                 xlog("L_INFO","NATMANAGE ru before handle_ruri_alias: $ru\n");
                 add_contact_alias();
                 xlog("L_INFO","NATMANAGE du after handle_ruri_alias: $du\n");
                 xlog("L_INFO","NATMANAGE ru after handle_ruri_alias: $ru\n");
              }
	   }
	}
	xlog("L_INFO","=>calling route(NATMANAGE) Complete\n");
#!endif
	return;
}

# URI update for dialog requests
route[DLGURI] {
xlog("L_INFO","FLOW - route[DLGURI]\n");
#!ifdef WITH_NAT
	#if(!isdsturiset()) {
        if ($du == "") {
             xlog("L_INFO","DLGI du before handle_ruri_alias: $du\n");
             xlog("L_INFO","DLGI ru before handle_ruri_alias: $ru\n");
             handle_ruri_alias();
             switch ($rc) {
             case -1:
                 xlog("L_INFO", "Failed to handle alias of R-URI $ru\n");
                 send_reply("400", "Bad request");
                 exit;
             case 1:
                 xlog("L_INFO", "Routing in-dialog $rm from $fu to $du\n");
                 break;
             case 2:
                 xlog("L_INFO", "Routing in-dialog $rm from $fu to $ru\n");
                 break;
             };
             xlog("L_INFO","DLGI du after handle_ruri_alias: $du\n");
             xlog("L_INFO","DLGI ru after handle_ruri_alias: $ru\n");
         }
         else {
             xlog("L_INFO", "du already set: $du\n");
         };
	#}
#!endif
	return;
}

route[DETECT_ASTERISK_SERVER] {
   xlog("L_INFO","FLOW - route[DETECT_ASTERISK_SERVER]\n");
      #$var(fu)=$fU;
      #$var(user) = $(ru{re.subst,/^sip:(.*)@(.*)/\1/});
      #$var(caller) = $(fu{re.subst,[0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]});
   xlog("L_INFO","          request number: $rU\n");
   sql_query("ca", "select ipaddr from sipregs where name = '$rU'", "ra");
   if($dbr(ra=>rows)>0) {
      xlog("L_INFO","   FLOW : DB Values\n");
      $var(i) = 0;
      /*
      while($var(i)<$dbr(ra=>cols)) {
        xlog("L_INFO", "      --- SCRIPT: column[$var(i)] = $dbr(ra=>colname[$var(i)])\n");
        $var(i) = $var(i) + 1;
      }
      $var(i) = 0;
      while($var(i)<$dbr(ra=>rows)) {
        $var(j) = 0;
        while($var(j)<$dbr(ra=>cols)) {
          xlog("L_INFO","        [$var(i),$var(j)] = $dbr(ra=>[$var(i),$var(j)])\n");
          $var(j) = $var(j) + 1;
        }
        $var(i) = $var(i) + 1;
      }
      */
      xlog("L_INFO","        Asterisk IP = $dbr(ra=>[0,0])\n");
      xlog("L_INFO","          request: $rm from $fu to $ru\n");
      $du = "sip:" + $dbr(ra=>[0,0]) + ":" + $sel(cfg_get.asterisk.bindport) + ";lr" +";nat=yes";
      $dlg_var(asteriskserver) = $dbr(ra=>[0,0]);
      dlg_manage();
      xlog("L_INFO","          du assigned to $du\n");
   }
   sql_result_free("ra");
}

route[RTPPROXY] {
xlog("L_INFO","FLOW - route[RTPPROXY]\n");
   if (is_method("BYE")) {
      rtpengine_delete();
   }
   else if (is_method("INVITE")) {
      if (has_body("application/sdp")) {
         xlog("L_INFO","=>In route(RTPPROXY)\n");
         #rtpengine_offer();
         //Using manage over offer fixes no Video on WebRTC client issue on some devices - 09152018
         rtpengine_manage("ICE=force");
         //rtpengine_manage();
     }
   }
   #if (!has_totag()) add_rr_param(";nat=yes");
   return;
}

# Routing to foreign domains
route[SIPOUT] {
xlog("L_INFO","FLOW - route[SIPOUT]\n");
	if (uri==myself) {
           xdbg("Dbg=>Nothing to do(uri==myself) so exit route [SIPOUT]\n");
           return;
        }
	append_hf("P-hint: outbound\r\n");
        xdbg("Dbg=>Calling route(RELAY)\n");
	route(RELAY);
        xlog("L_INFO","=>route[SIPOUT] Complete\n");
/*
              // TEST 9/10/2018
	exit; 
	return;
              // TEST 9/10/2018
*/
}

# PSTN GW routing
route[PSTN] {
#!ifdef WITH_PSTN
        xlog("L_INFO","FLOW - route[PSTN]\n");
	# check if PSTN GW IP is defined
	if (strempty($sel(cfg_get.pstn.gw_ip))) {
		xlog("SCRIPT: PSTN routing enabled but pstn.gw_ip not defined\n");
		return;
	}

	# route to PSTN dialed numbers starting with '+' or '00'
	#     (international format)
	# - update the condition to match your dialing rules for PSTN routing
	if(!($rU=~"^(\+|00)[1-9][0-9]{3,20}$")) return;

	# only local users allowed to call
	if(from_uri!=myself) {
                xlog("L_INFO","=>SIP Reply in PSTN '403 - Not Allowed'\n");
                xlog("L_INFO","");
		sl_send_reply("403", "Not Allowed");
		exit;
	}

	if (strempty($sel(cfg_get.pstn.gw_port))) {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip);
	} else {
		$ru = "sip:" + $rU + "@" + $sel(cfg_get.pstn.gw_ip) + ":"
					+ $sel(cfg_get.pstn.gw_port);
	}

	route(RELAY);
	exit;
#!endif

	return;
}

# XMLRPC routing
#!ifdef WITH_XMLRPC
route[XMLRPC] {
        xlog("L_INFO","FLOW - route[XMLRPC]\n");
	# allow XMLRPC from localhost
        xdbg("Dbg=>In route[XMLRPC]\n");
	if ((method=="POST" || method=="GET")
			&& (src_ip==127.0.0.1)) {
		# close connection only for xmlrpclib user agents (there is a bug in
		# xmlrpclib: it waits for EOF before interpreting the response).
		if ($hdr(User-Agent) =~ "xmlrpclib")
			set_reply_close();
		set_reply_no_connect();
		dispatch_rpc();
		exit;
	}
	send_reply("403", "Forbidden");
	exit;
}
#!endif

# Routing to voicemail server
route[TOVOICEMAIL] {
#!ifdef WITH_VOICEMAIL
        xlog("L_INFO","FLOW - route[TOVOICEMAIL]\n");
	if(!is_method("INVITE|SUBSCRIBE")) return;

	# check if VoiceMail server IP is defined
	if (strempty($sel(cfg_get.voicemail.srv_ip))) {
		xlog("SCRIPT: VoiceMail routing enabled but IP not defined\n");
		return;
	}
	if(is_method("INVITE")) {
		if($avp(oexten)==$null) return;

		$ru = "sip:" + $avp(oexten) + "@" + $sel(cfg_get.voicemail.srv_ip)
				+ ":" + $sel(cfg_get.voicemail.srv_port);
	} else {
		if($rU==$null) return;

		$ru = "sip:" + $rU + "@" + $sel(cfg_get.voicemail.srv_ip)
				+ ":" + $sel(cfg_get.voicemail.srv_port);
	}
	route(RELAY);
	exit;
#!endif

	return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
        xlog("L_INFO","FLOW - branch_route[MANAGE_BRANCH] => Just calls route(NATMANAGE)\n");
	route(NATMANAGE);
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
        xlog("L_INFO","FLOW - onreply_route[MANAGE_REPLY]\n");
        if (has_body("application/sdp")) {
           //if((isflagset(FLT_NATS) || isbflagset(FLB_NATB)) && status=~"(183)|(2[0-9][0-9])") {
              rtpengine_manage("ICE=force");
              //rtpengine_manage();
           //}
        }
        xdbg("Dbg=>In onreply_route[MANAGE_REPLY]\n");

	if(status=~"[12][0-9][0-9]") {
                xdbg("Dbg=>onreply_route status to route to NATMANAGE\n");
		route(NATMANAGE);
	}
        if (isbflagset("6")) {
	   #if(is_first_hop()) {
              xlog("L_INFO","onreply_route du before fix_nated_contact: $du\n");
              xlog("L_INFO","onreply_route ru before fix_nated_contact: $ru\n");
              fix_nated_contact();
              xlog("L_INFO","onreply_route du after fix_nated_contact: $du\n");
              xlog("L_INFO","onreply_route ru after fix_nated_contact: $ru\n");
           #}
        }
        xdbg("Dbg=>Exit onreply_route[MANAGE_REPLY]\n");
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
        xlog("L_INFO","FLOW - failure_route[MANAGE_FAILURE]\n");
        if (isflagset(6) || isflagset(5)) {
           if (has_body("application/sdp")) {
              rtpengine_manage("ICE=force");
              //rtpengine_manage();
           }
        }
        xdbg("Dbg=>In failure_route[MANAGE_FAILURE]\n");
	route(NATMANAGE);

	if (t_is_canceled()) exit;

#!ifdef WITH_BLOCK3XX
	# block call redirect based on 3xx replies.
	if (t_check_status("3[0-9][0-9]")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_BLOCK401407
	# block call redirect based on 401, 407 replies.
	if (t_check_status("401|407")) {
		t_reply("404","Not found");
		exit;
	}
#!endif

#!ifdef WITH_VOICEMAIL
	# serial forking
	# - route to voicemail on busy or no answer (timeout)
	if (t_check_status("486|408")) {
		$du = $null;
		route(TOVOICEMAIL);
		exit;
	}
#!endif
}

#!ifdef WITH_ASTERISK

# Test if coming from Asterisk
#!ifdef WITH_DISPATCHER
route[FROMASTERISK] {
   xlog("L_INFO","FLOW - route[FROMASTERISK]\n");
   if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
      xlog("L_INFO","=>In route(FROMASTERISK):$si dispatcher on\n");
   }
   if(ds_is_from_list()){
        xlog("L_INFO","[$fU@$si:$sp]{$rm} Call from Media-Server Cluster\n");
        return 1;
   }
   if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
      xdbg("Dbg=>In route(FROMASTERISK) Complete: Not coming from Asterisk\n");
   }
   return -1;
}
#!else 
route[FROMASTERISK] {
   xlog("L_INFO","FLOW - route[FROMASTERISK]\n");
   if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
      xlog("L_INFO","=>In route(FROMASTERISK) si:$si sp:$sp\n");
   }
   if($si==$dlg_var(asteriskserver) && $sp==$sel(cfg_get.asterisk.bindport)) {
      xlog("L_DBG","=>route(FROMASTERISK) Complete:Coming from Asterisk\n");
      xlog("L_DBG","==>$si\n");
      return 1;
   }
   if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
      xlog("L_DBG","=>route(FROMASTERISK) Complete:Not coming from Asterisk\n");
   }
   return -1;
}
#!endif
 
# Send to Asterisk
#!ifdef WITH_DISPATCHER
route[TOASTERISK] {
        xlog("L_INFO","FLOW - route[TOASTERISK]\n");
        # => I think this should be "IP" and maybe just "I"  08252018
        ds_mark_dst("P"); 
        #4=>round robin
        #6=>random
        #8=>use first destination
        #ds_select_dst will set $du based on algorythm choose and values in the kamailio dispatcher table
        if(!ds_select_dst("1", "4")) {
           xlog("L_INFO","=>SIP Reply '500 - Service Unavailable'\n");
           sl_send_reply("500", "Service Unavailable");
           xlog("L_INFO","[$fU@$si:$sp]{$rm} No destinations available for $rd \n");
           exit;
        }

        xlog("L_INFO","[$fU@$si:$sp]{$rm} From Outside World to Asterisk Box $du\n");

        route(RELAY);
        exit;
}
#!else
route[TOASTERISK] {
        xlog("L_INFO","FLOW - route[TOASTERISK]\n");
#!ifdef WITH_DETECT_ASTERISK
        route(DETECT_ASTERISK_SERVER);
	#$du = "sip:" + $dlg_var(asteriskserver) + ":" + $sel(cfg_get.asterisk.bindport);
#!else
	$du = "sip:" + $sel(cfg_get.asterisk.bindip) + ":" + $sel(cfg_get.asterisk.bindport);
#!endif
        xlog("L_INFO","=> du:$du\n");
        xlog("L_INFO","=> ru:$ru\n");

/*
        //STEVE NEW 5/11/2018
	# If authorization user is identical to From: username, I will assume this is
	# a call coming from an extension within a domain. Otherwise, this request
	# will be unchanged, for incoming SIP trunks.
	if ($au == $fU) {
		xlog("L_ALERT", "INFO: Authorization user=$au From user=$fU , mangling...");
		# Encode domain part into username
		$var(newfrom) = $fU + "_" + $fd;
		$var(newfromuri) = "sip:" + $(var(newfrom){s.escape.user}) + "@" + $dlg_var(asteriskserver) + ":" + $sel(cfg_get.asterisk.bindport);
		uac_replace_from("$var(newfromuri)");
		$var(newto) = $tU + "_" + $td;
		$var(newtouri) = "sip:" + $(var(newto){s.escape.user}) + "@" + $dlg_var(asteriskserver) + ":" + $sel(cfg_get.asterisk.bindport);
		uac_replace_to("$var(newtouri)");
	} else {
		xlog("L_ALERT", "INFO: Authorization user=$au From user=$fU , NOT mangling...");
		if ($au != "") {
			$var(newfromuri) = "sip:" + $au + "@" + $fd;
			uac_replace_from("$var(newfromuri)");
		}
	}
        //STEVE END NEW 5/11/2018
*/


        xdbg("Dbg=>Calling route(RELAY)\n");
	route(RELAY);
        xdbg("Dbg=>route(TOASTERISK) via dispatcher Complete\n");
	exit;
}
#!endif

 
# Forward REGISTER to Asterisk
#!ifdef WITH_DISPATCHER
route[REGFWD] {
    xlog("L_INFO","FLOW - route[REGFWD] Dispatcher\n");
    ds_mark_dst("P");
    if(ds_select_dst("1", "4")) {
        xlog("L_INFO", "=>In route(REGFWD) to Asterisk\n");
	if(!is_method("REGISTER"))
	{
           xdbg("Dbg=>route(REGFWD):exiting not a REGISTER\n");
	   return;
	}
        xlog("L_INFO","=>Sending registration to Asterisk at $ru; $du\n");
/*
        the next line is getting the private ip address from the db (dispatcher), you may need the 
        public ip, depending on NAT conditions
*/
        $var(rip) = $(du{s.select,1,:});
        $var(rport) = $(du{s.select,2,:});
	$uac_req(method)="REGISTER";
	$uac_req(ruri)="sip:" + $var(rip) + ":" + $var(rport) + ";lr" + ";transport=tcp";
	$uac_req(furi)="sip:" + $au + "@" + $var(rip);
	$uac_req(turi)="sip:" + $au + "@" + $var(rip);
	$uac_req(hdrs)="Contact: <sip:" + $au + "@"
				+ $sel(cfg_get.kamailio.bindip)
				+ ":" + $sel(cfg_get.kamailio.bindport) + ">\r\n";
	if($sel(contact.expires) != $null)
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $sel(contact.expires) + "\r\n";
	else
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $hdr(Expires) + "\r\n";
        xlog ("L_INFO", "=> In REGFWD, sending to IP: $var(rip)");
        xlog ("L_INFO", "=> In REGFWD, sending registration info to Asterisk at $uac_req(ruri)");
	uac_req_send();
        //sip_trace();
        xlog("L_INFO", "=>route(REGFWD) to Asterisk Complete\n");
    } 
}
#!else
route[REGFWD] {
        xlog("L_INFO","FLOW - route[REGFWD]\n");
	if(!is_method("REGISTER"))
	{
		return;
	}
	$var(rip) = $dlg_var(asteriskserver);
	$uac_req(method)="REGISTER";
	$uac_req(ruri)="sip:" + $var(rip) + ":" + $sel(cfg_get.asterisk.bindport);

	# Encode domain part into username
        $var(newfrom) = $fU + "_" + $fd;
        $var(newfromuri) = "sip:" + $(var(newfrom){s.escape.user}) + "@" + $dlg_var(asteriskserver) + ":" + $sel(cfg_get.asterisk.bindport);
        uac_replace_from("$var(newfromuri)");
        $var(newto) = $tU + "_" + $td;
        $var(newtouri) = "sip:" + $(var(newto){s.escape.user}) + "@" + $dlg_var(asteriskserver) + ":" + $sel(cfg_get.asterisk.bindport);
        uac_replace_to("$var(newtouri)");

	$var(encodeuser) = $au + "_" + $fd;
	$uac_req(furi)=$var(newfromuri);

	$uac_req(turi)=$var(newtouri);

	$var(encodeuser) = $au + "_" + $fd;
	$uac_req(hdrs)="Contact: <sip:" + $(var(encodeuser){s.escape.user}) + "@"
				+ $sel(cfg_get.kamailio.bindip)
				+ ":" + $sel(cfg_get.kamailio.bindport) + ">\r\n";
	if($sel(contact.expires) != $null)
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $sel(contact.expires) + "\r\n";
	else
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $hdr(Expires) + "\r\n";
	uac_req_send();
}
#!endif
route[REGFWDX] {
        xlog("L_INFO","=>In route(REGFWDX), Forwarding Registration to Asterisk\n");
	if(!is_method("REGISTER"))
	{
           xdbg("Dbg=>route(REGFWD):exiting not a REGISTER\n");
	   return;
	}
/*
        the next line is getting the public ip address, you may need the private ip, depending on NAT conditions
*/
	//$var(rip) = $sel(cfg_get.asterisk.publicip);
	$var(rip) = $dlg_var(asteriskserver);
	$var(rport) = $sel(cfg_get.asterisk.bindport);
        xlog("L_INFO","=>Sending registration to Asterisk at $var(rip):$var(rport) \n");

	$uac_req(method)="REGISTER";
	$uac_req(ruri)="sip:" + $var(rip) + ":" + $var(rport) +";lr" + ";transport=tcp"; 
	$uac_req(furi)="sip:" + $au + "@" + $var(rip);
	$uac_req(turi)="sip:" + $au + "@" + $var(rip);
	$uac_req(hdrs)="Contact: <sip:" + $au + "@"
				+ $sel(cfg_get.kamailio.bindip)
				+ ":" + $sel(cfg_get.kamailio.bindport) + ">\r\n";
	if($sel(contact.expires) != $null)
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $sel(contact.expires) + "\r\n";
	else
		$uac_req(hdrs)= $uac_req(hdrs) + "Expires: " + $hdr(Expires) + "\r\n";
        xlog ("L_INFO", "=> In REGFWD, sending registration info to Asterisk at $uac_req(ruri)");
	uac_req_send();
        //sip_trace();
        xlog("L_INFO", "=>route(REGFWD) to Asterisk Complete\n");
        return;
}

#end of main WITH_ASTERISK branch
#!endif

route[HOMER_SECURITY_CHECKS] {
  xlog("L_INFO","FLOW - route[HOMER_SECURITY_CHECKS]\n");
  if (is_method("INVITE|REGISTER")) {
        xdbg("Dbg=>Incoming:Homer security checks called\n");

        if($ua =~ "(friendly-scanner|sipvicious)") {
          xlog("L_INFO","ALERT: Scriptkiddie attack, coming from $si, call blocked");
          exit;
        }

        #hostname in contact
        if($sel(contact.uri.host) =~ "^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})$") {
          xlog("L_INFO","ALERT: Someone coming from $si using IP addressess instead of DNS ?, call blocked");
          exit;
        }

        if($au =~ "(\=)|(\-\-)|(')|(\#)|(\%27)|(\%24)" and $au != $null) {
          xlog("L_INFO","ALERT: Homer:Someone from $si is doing an sql injection attack, call blocked");
          exit;
        }

        if($(hdr(Record-Route)[0]{nameaddr.uri}) != $si and $(hdr(Record-Route)[0]{nameaddr.uri}) != $null) {
          if ((allow_trusted("$si", "$proto")) || (allow_source_address(1))) {
            xlog("L_INFO","ALERT: Potential Spoofing attack detected from $si, call trusted");
            return;
          }
          else {
            xlog("L_INFO","ALERT: Spoofing attack detected from $si, call blocked");
            exit;
          }
        }
        xdbg("Dbg=>Homer security checks complete\n");
  }
}

reply_route {
   xlog("L_INFO","FLOW - reply_route - display only\n");
   xlog("L_INFO","   FLOW : SIP Incoming Response: $mb\n");
}

#!ifdef WITH_WEBSOCKETS
onreply_route {
        xlog("L_INFO","FLOW - onreply_route - WEBSOCKET\n");
        if (has_body("application/sdp")) {
           rtpengine_manage("ICE=force");
           //rtpengine_manage();
        }
        xdbg("Dbg=>Web Socket onreply_route\n");
	if ($Rp == MY_WS_PORT || $Rp == MY_WSS_PORT) {
		xlog("L_INFO", "=>SIP response received on $Rp\n");
		#drop;
		#exit;
	}
 
	if (nat_uac_test(64)) {
                xlog("L_INFO","=>Web Socket: Do NAT traversal for connection\n");
		# Do NAT traversal stuff for replies to a WebSocket connection
		# - even if it is not behind a NAT!
		# This won't be needed in the future if Kamailio and the
		# WebSocket client support Outbound and Path.
             xlog("L_INFO","onreply_route du before add_contact_alias: $du\n");
             xlog("L_INFO","onreply_route ru before add_contact_alias: $ru\n");
             add_contact_alias();
             xlog("L_INFO","onreply_route du after add_contact_alias: $du\n");
             xlog("L_INFO","onreply_route ru after add_contact_alias: $ru\n");
	}
}

onsend_route {
    xlog("L_INFO","FLOW - onsend_route\n");
    if(((method!="OPTIONS") && (method!="INFO")) || $avp(chatty)=="yes") {
      xlog("L_INFO","   FLOW : SIP Outgoing: [[$sndto(buf)]]\n");
    }
}

 
event_route[xhttp:request] {
        xlog("L_INFO","FLOW - onevent_route\n");
#!ifdef TEST_WEBSOCKETS
        xhttp_reply("200", "OK", "text/html","<html><body>Received HTTP request to $hu from [$si:$sp] with protocol $proto</body></html>");
        return;
#!endif
	set_reply_close();
	set_reply_no_connect();
	
	if ($Rp != MY_WS_PORT
#!ifdef WITH_TLS
	    && $Rp != MY_WSS_PORT
#!endif
	) {
	#	xlog("L_WARN", "HTTP request received on $Rp\n");
        #	xhttp_reply("403", "Forbidden", "", "");
	#	exit;
             xdbg("Dbg=>Allow Forbidden action if from Asterisk on $Rp\n");
	}
 
	xlog("L_DBG", "HTTP Request Received\n");
 
	if ($hdr(Upgrade)=~"websocket"
			&& $hdr(Connection)=~"Upgrade"
			&& $rm=~"GET") {
 
		# Validate Host - make sure the client is using the correct
		# alias for WebSockets
                #http://sip-router.1086192.n5.nabble.com/Testing-the-Websocket-module-with-sipml5-org-td65069.html
                #if ($hdr(Host) == $null || !is_myself("sip:" + $hdr(Host))) {
		#	xlog("L_WARN", "Bad host $hdr(Host)\n");
		#	xhttp_reply("403", "Forbidden", "", "");
		#	exit;
		#}
 
		# Optional... validate Origin - make sure the client is from an
		# authorised website.  For example,
		#
		# if ($hdr(Origin) != "http://communicator.MY_DOMAIN"
		#     && $hdr(Origin) != "https://communicator.MY_DOMAIN") {
		#	xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
		#	xhttp_reply("403", "Forbidden", "", "");
		#	exit;
		# }
 
		# Optional... perform HTTP authentication
		# ws_handle_handshake() exits (no further configuration file
		# processing of the request) when complete.
		if (ws_handle_handshake())
		{
			# Optional... cache some information about the
			# successful connection
			exit;
		}
	}
 
	xhttp_reply("404", "Not Found", "", "");
}
 
event_route[websocket:closed] {
        xlog("L_INFO","FLOW - event_route[websocket:closed]\n");
}

#!endif


#!ifdef WITH_DISPATCHER
failure_route[RTF_DISPATCH] {
        xlog("L_INFO","FLOW - failure_route[RTF_DISPATCHER]\n");
        if (t_is_canceled()) {
           xdbg("Dbg=>Bailing\n");
           exit;
        }
        # next DST - only for 500 or local timeout
        if (t_check_status("500") or (t_branch_timeout() and !t_branch_replied()))
        {
           xdbg("Dbg=> DISPATCH route looking for next route\n");
           if(ds_next_dst())
           {
              t_on_failure("RTF_DISPATCH");
              xdbg("Dbg=> DISPATCH routing: Calling route(RELAY) with found route\n");
              return; //exit;
            }
            else {
              send_reply("404", "No destination");
            }
        }
 }
#!endif
